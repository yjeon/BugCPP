#include "BugAlgorithms.hpp"
#include <math.h>
#include <iostream>
#define KNRM  "\x1B[0m"
#define KRED  "\x1B[31m"
#define KGRN  "\x1B[32m"
#define KYEL  "\x1B[33m"
#define KBLU  "\x1B[34m"
#define KMAG  "\x1B[35m"
#define KCYN  "\x1B[36m"
#define KWHT  "\x1B[37m"

/**
 * Personal Reference
 * 1) ~FunctionName implies that it is a destructor
 * 2) :: a.k.a 'class resolution operator'
 * 3) (2) means that it is declaringa a member object
 */

const double PI = 3.14159265359;

// Just a constructor
// Simulator loads up the obstacle.txt to generate the simulation env.
BugAlgorithms::BugAlgorithms(Simulator * const simulator) {
  m_simulator = simulator;   

	m_mode = STRAIGHT;
	m_hit[0] = m_hit[1] = HUGE_VAL;
	m_leave[0] = m_leave[1] = 0;
	m_distLeaveToGoal = HUGE_VAL;
}

BugAlgorithms::~BugAlgorithms(void) {
    // do not delete m_simulator  
}

/**
std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
std::cout.precision(4);
**/

/**
 * Pseudocode
 * 1. Set robot initial coordinates
 * 2. Set goal coordinates
 * 3, Loop:
 * 		1. Check if too close to a boundary.
 * 			1. If yes, follow a boundary
 * 			2. If no,  go towards the goal coordinate in a straight line.
 * 4. Update current coordinates
 * 5. Back to 1.
 */
Move BugAlgorithms::Bug0(Sensor sensor) {
	Move move = {0, 0}; //initial movement, double {m_dx, m_dy}

	double goalX  = m_simulator->GetGoalCenterX();  // goal coordinate X
	double goalY  = m_simulator->GetGoalCenterY();  // goal coordinate Y
	double currX  = m_simulator->GetRobotCenterX(); // robot current coordinate X
	double currY  = m_simulator->GetRobotCenterY(); // robot current coordinate Y

	double dx_g   = goalX - currX;
	double dy_g   = goalY - currY;
	double dx_o   = sensor.m_xmin - currX;
	double dy_o   = sensor.m_ymin - currY;

	double distG  = sqrt(pow(dx_g, 2) + pow(dy_g, 2));
	double distO  = sqrt(pow(dx_o, 2) + pow(dy_o, 2));

	double theta  = atan2(dy_g, dx_g);
	double theta_o= atan2(dy_o, dx_o);
	
	double dirX, dirY; // vectors to move robot x and y directions
	if(sqrt(sensor.m_dmin) <= m_simulator->GetWhenToTurn()) {
		dirX = cos(theta_o) * -1;
		move.m_dx = dirX * m_simulator->GetStep();
		move.m_dy = dirY * m_simulator->GetStep();
		printf("%s===============================================\n", KGRN);
		printf("Wall Following\n");
		printf("currX: %+6f\t currY: %+6f\n", currX, currY);
		printf("goalX: %+6f\t goalY: %+6f\n", goalX, goalY);
		printf(" dirX: %+6f\t  dirY: %+6f\n", dirX, dirY);
		printf(" m_dx: %+6f\t  m_dy: %+6f\n", move.m_dx, move.m_dy);
		printf("mxmin: %+6f\t mymin: %+6f\n", sensor.m_xmin, sensor.m_ymin);
		printf("mdmin: %+6f\n", sensor.m_dmin);
		printf("theta: %+6f\t\t\t\n", theta_o);
	} else {
		dirX = cos(theta);
		dirY = sin(theta);
		move.m_dx = dirX * m_simulator->GetStep();
		move.m_dy = dirY * m_simulator->GetStep();
		printf("%s===============================================\n", KCYN);
		printf("Heading to Goal\n");
		printf("currX: %+6f\t currY: %+6f\n", currX, currY);
		printf("goalX: %+6f\t goalY: %+6f\n", goalX, goalY);
		printf(" dirX: %+6f\t  dirY: %+6f\n", dirX, dirY);
		printf(" m_dx: %+6f\t  m_dy: %+6f\n", move.m_dx, move.m_dy);
		printf("mxmin: %+6f\t mymin: %+6f\n", sensor.m_xmin, sensor.m_ymin);
		printf("mdmin: %+6f\n", sensor.m_dmin);
		printf("theta: %+6f\t\t\t\n", theta);
	}

	return move;
}

Move BugAlgorithms::Bug1(Sensor sensor) {
    Move move 	= {0, 0}; //initial movement, double {m_dx, m_dy}
	
	double gX 	= m_simulator->GetGoalCenterX(); 
	double gY 	= m_simulator->GetGoalCenterY();
	double rX 	= m_simulator->GetRobotCenterX();
	double rY 	= m_simulator->GetRobotCenterY();
	double oX	= sensor.m_xmin;
	double oY	= sensor.m_ymin;

	double dgX	= gX - rX;
	double dgY  = gY - rY;
	double doX  = oX - rX;
	double doY  = oY - rY;
	double dG   = sqrt(pow(dgX, 2) + pow(dgY, 2));
	double dO   = sqrt(pow(doX, 2) + pow(doY, 2));

	double mX   = dgX / dG;
	double mY   = dgY / dG;

	double rX_n = rX + mX;
	double rY_n = rY + mY;
	double doX_n= oX - rX_n;
	double doY_n= oY - rY_n;
	double dO_n = sqrt(pow(doX_n, 2) + pow(doY_n, 2));

	if(dO_n <= 1) {
		mX = doX_n / dO_n;
		mY = doY_n / dO_n;
		move.m_dx = mX * 0.06;
		move.m_dy = mY * 0.06;
		printf("obs || dO: %f\n", dO);
	} else {
		move.m_dx = mX * 0.06;
		move.m_dy = mY * 0.06;
		printf("goal\n");
	}

    return move;
}

Move BugAlgorithms::Bug2(Sensor sensor) {
    //add your implementation
    Move move ={0,0};
    
    return move;
}
